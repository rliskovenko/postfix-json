diff --git a/conf/main.cf b/conf/main.cf
index cb86128..8d301aa 100644
--- a/conf/main.cf
+++ b/conf/main.cf
@@ -592,15 +592,7 @@ debug_peer_level = 2
 #
 debugger_command =
 	 PATH=/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin
-	 ddd --gdb $daemon_directory/$process_name $process_id & sleep 10
-#debugger_command =
-#    PATH=/bin:/usr/bin:/usr/local/bin;
-#    (ltrace -a -p $process_id 2>&1 | logger -p mail.info) & sleep 5
-#debugger_command =
-#    PATH=/bin:/usr/bin:/usr/local/bin; export PATH; (echo cont; echo
-#    where; sleep 8640000) | gdb $daemon_directory/$process_name
-#    $process_id 2>&1
-#    >$config_directory/$process_name.$process_id.log & sleep 5
+	 ddd $daemon_directory/$process_name $process_id & sleep 5
 
 # If you can't use X, use this to capture the call stack when a
 # daemon crashes. The result is in a file in the configuration
@@ -663,10 +655,3 @@ sample_directory =
 #
 readme_directory =
 inet_protocols = ipv4
-
-queue_metadata_url = http://localhost:9300/
-queue_metadata_changeq_path = /message/change_queue
-queue_metadata_changewt_path = /message/change_waittime
-queue_metadata_addq_path = /message/add
-queue_metadata_rmq_path = /message/remove
-
diff --git a/conf/post-install b/conf/post-install
old mode 100755
new mode 100644
diff --git a/conf/postfix-files b/conf/postfix-files
old mode 100755
new mode 100644
diff --git a/conf/postfix-script b/conf/postfix-script
old mode 100755
new mode 100644
diff --git a/conf/postfix-wrapper b/conf/postfix-wrapper
old mode 100755
new mode 100644
diff --git a/conf/postmulti-script b/conf/postmulti-script
old mode 100755
new mode 100644
diff --git a/makedefs b/makedefs
index 5cfcbeb..93b5949 100644
--- a/makedefs
+++ b/makedefs
@@ -366,7 +366,7 @@ EOF
 		    SYSLIBS="-ldb"
 		    ;;
 		esac
-		for name in nsl resolv curl m
+		for name in nsl resolv
 		do
 		    for lib in /usr/lib64 /lib64 /usr/lib /usr/lib/* /lib /lib/*
 		    do
diff --git a/src/cleanup/cleanup.h b/src/cleanup/cleanup.h
index d34ba95..9b9d627 100644
--- a/src/cleanup/cleanup.h
+++ b/src/cleanup/cleanup.h
@@ -54,7 +54,6 @@ typedef struct CLEANUP_STATE {
     MAIL_STREAM *handle;		/* mail stream handle */
     char   *queue_name;			/* queue name */
     char   *queue_id;			/* queue file basename */
-    char    *msg_subject;   /* saved message subject */
     struct timeval arrival_time;	/* arrival time */
     char   *fullname;			/* envelope sender full name */
     char   *sender;			/* envelope sender address */
diff --git a/src/cleanup/cleanup_api.c b/src/cleanup/cleanup_api.c
index 9d63b57..ffcd93f 100644
--- a/src/cleanup/cleanup_api.c
+++ b/src/cleanup/cleanup_api.c
@@ -121,8 +121,6 @@
 
 #include "cleanup.h"
 
-extern char* new_url;
-
 /* cleanup_open - open queue file and initialize */
 
 CLEANUP_STATE *cleanup_open(VSTREAM *src)
@@ -244,13 +242,6 @@ int     cleanup_flush(CLEANUP_STATE *state)
     if (CLEANUP_OUT_OK(state))
 	cleanup_final(state);
 
-    // Workarounf for empty subject line
-    if ( state->msg_subject == 0 )
-        state->msg_subject = mystrdup("");
-    restlog_queued( new_url, state->queue_id, state->queue_name, state->sender,
-        state->recip, state->rcpt_count, state->msg_subject,
-        (unsigned long)state->cont_length);
-
     /*
      * If there was an error that requires us to generate a bounce message
      * (mail submitted with the Postfix sendmail command, mail forwarded by
diff --git a/src/cleanup/cleanup_init.c b/src/cleanup/cleanup_init.c
index 7ed678e..47ed5cf 100644
--- a/src/cleanup/cleanup_init.c
+++ b/src/cleanup/cleanup_init.c
@@ -165,10 +165,6 @@ char   *var_milt_head_checks;		/* post-Milter header checks */
 int     var_auto_8bit_enc_hdr;		/* auto-detect 8bit encoding header */
 int     var_always_add_hdrs;		/* always add missing headers */
 
-char *new_url;
-char    *var_queue_metadata_url;
-char    *var_queue_metadata_addq_path;
-
 CONFIG_INT_TABLE cleanup_int_table[] = {
     VAR_HOPCOUNT_LIMIT, DEF_HOPCOUNT_LIMIT, &var_hopcount_limit, 1, 0,
     VAR_DUP_FILTER_LIMIT, DEF_DUP_FILTER_LIMIT, &var_dup_filter_limit, 0, 0,
@@ -233,8 +229,6 @@ CONFIG_STR_TABLE cleanup_str_table[] = {
     VAR_MILT_UNK_MACROS, DEF_MILT_UNK_MACROS, &var_milt_unk_macros, 0, 0,
     VAR_CLEANUP_MILTERS, DEF_CLEANUP_MILTERS, &var_cleanup_milters, 0, 0,
     VAR_MILT_HEAD_CHECKS, DEF_MILT_HEAD_CHECKS, &var_milt_head_checks, 0, 0,
-    VAR_QUEUE_METADATA_URL, DEF_QUEUE_METADATA_URL, &var_queue_metadata_url, 1, 0,
-    VAR_QUEUE_METADATA_ADDQ_PATH, DEF_QUEUE_METADATA_ADDQ_PATH, &var_queue_metadata_addq_path, 1, 0,
     0,
 };
 
@@ -311,11 +305,6 @@ void    cleanup_sig(int sig)
 
 void    cleanup_pre_jail(char *unused_name, char **unused_argv)
 {
-    /* Initialize new message url */
-    new_url = mystrdup( var_queue_metadata_url );
-    new_url = (char *) myrealloc( new_url, strlen(var_queue_metadata_url) + strlen(var_queue_metadata_addq_path ) + 2 );
-    new_url = strcat(new_url, var_queue_metadata_addq_path );
-
     static const NAME_MASK send_canon_class_table[] = {
 	CANON_CLASS_ENV_FROM, CLEANUP_CANON_FLAG_ENV_FROM,
 	CANON_CLASS_HDR_FROM, CLEANUP_CANON_FLAG_HDR_FROM,
diff --git a/src/cleanup/cleanup_message.c b/src/cleanup/cleanup_message.c
index b8b92de..ffb5c7e 100644
--- a/src/cleanup/cleanup_message.c
+++ b/src/cleanup/cleanup_message.c
@@ -574,11 +574,6 @@ static void cleanup_header_callback(void *context, int header_class,
      */
     else {
 	state->headers_seen |= (1 << hdr_opts->type);
-        // Save Subject header
-        if (hdr_opts->type == HDR_SUBJECT ) {
-            state->msg_subject = mystrdup( hdrval );
-            msg_info("%s: subject=%s", state->queue_id, hdrval);
-        }
 	if (hdr_opts->type == HDR_MESSAGE_ID)
 	    msg_info("%s: message-id=%s", state->queue_id, hdrval);
 	if (hdr_opts->type == HDR_RESENT_MESSAGE_ID)
diff --git a/src/cleanup/cleanup_state.c b/src/cleanup/cleanup_state.c
index 69b9b42..8d90852 100644
--- a/src/cleanup/cleanup_state.c
+++ b/src/cleanup/cleanup_state.c
@@ -125,7 +125,6 @@ CLEANUP_STATE *cleanup_state_alloc(VSTREAM *src)
     state->milter_ext_from = 0;
     state->milter_ext_rcpt = 0;
     state->milter_err_text = 0;
-    state->msg_subject = 0;
     state->free_regions = state->body_regions = state->curr_body_region = 0;
     return (state);
 }
@@ -143,8 +142,6 @@ void    cleanup_state_free(CLEANUP_STATE *state)
 	myfree(state->fullname);
     if (state->sender)
 	myfree(state->sender);
-	if (state->msg_subject)
-        myfree(state->msg_subject);
     if (state->recip)
 	myfree(state->recip);
     if (state->orig_rcpt)
diff --git a/src/global/Makefile.in b/src/global/Makefile.in
index 188bfa4..664d772 100644
--- a/src/global/Makefile.in
+++ b/src/global/Makefile.in
@@ -32,7 +32,7 @@ SRCS	= abounce.c anvil_clnt.c been_here.c bounce.c bounce_log.c \
 	match_service.c mail_conf_nint.c addr_match_list.c mail_conf_nbool.c \
 	smtp_reply_footer.c safe_ultostr.c verify_sender_addr.c \
 	dict_memcache.c mail_version.c memcache_proto.c server_acl.c \
-	mkmap_fail.c haproxy_srvr.cJSON.c rest.c
+	mkmap_fail.c haproxy_srvr.c
 OBJS	= abounce.o anvil_clnt.o been_here.o bounce.o bounce_log.o \
 	canon_addr.o cfg_parser.o cleanup_strerror.o cleanup_strflags.o \
 	clnt_stream.o conv_time.o db_common.o debug_peer.o debug_process.o \
@@ -66,7 +66,7 @@ OBJS	= abounce.o anvil_clnt.o been_here.o bounce.o bounce_log.o \
 	match_service.o mail_conf_nint.o addr_match_list.o mail_conf_nbool.o \
 	smtp_reply_footer.o safe_ultostr.o verify_sender_addr.o \
 	dict_memcache.o mail_version.o memcache_proto.o server_acl.o \
-	mkmap_fail.o haproxy_srvr.o cJSON.o rest.o
+	mkmap_fail.o haproxy_srvr.o
 HDRS	= abounce.h anvil_clnt.h been_here.h bounce.h bounce_log.h \
 	canon_addr.h cfg_parser.h cleanup_user.h clnt_stream.h config.h \
 	conv_time.h db_common.h debug_peer.h debug_process.h defer.h \
@@ -93,12 +93,10 @@ HDRS	= abounce.h anvil_clnt.h been_here.h bounce.h bounce_log.h \
 	fold_addr.h header_body_checks.h data_redirect.h match_service.h \
 	addr_match_list.h smtp_reply_footer.h safe_ultostr.h \
 	verify_sender_addr.h dict_memcache.h memcache_proto.h server_acl.h \
-	haproxy_srvr.h cJSON.h rest.h
+	haproxy_srvr.h
 TESTSRC	= rec2stream.c stream2rec.c recdump.c
 DEFS	= -I. -I$(INC_DIR) -D$(SYSTYPE)
 CFLAGS	= $(DEBUG) $(OPT) $(DEFS)
-LDFLAGS :=  $(shell curl-config --libs)
-SYSLIBS += -lcurl -lm
 INCL	=
 LIB	= libglobal.a
 TESTPROG= domain_list dot_lockfile mail_addr_crunch mail_addr_find \
@@ -116,7 +114,7 @@ LIB_DIR	= ../../lib
 INC_DIR	= ../../include
 MAKES	=
 
-.c.o:;	$(CC) $(LDFLAGS) $(CFLAGS) -c $*.c
+.c.o:;	$(CC) $(CFLAGS) -c $*.c
 
 all: $(LIB)
 
diff --git a/src/global/cJSON.c b/src/global/cJSON.c
deleted file mode 100644
index 04b5079..0000000
--- a/src/global/cJSON.c
+++ /dev/null
@@ -1,567 +0,0 @@
-/*
-  Copyright (c) 2009 Dave Gamble
-
-  Permission is hereby granted, free of charge, to any person obtaining a copy
-  of this software and associated documentation files (the "Software"), to deal
-  in the Software without restriction, including without limitation the rights
-  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-  copies of the Software, and to permit persons to whom the Software is
-  furnished to do so, subject to the following conditions:
-
-  The above copyright notice and this permission notice shall be included in
-  all copies or substantial portions of the Software.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-  THE SOFTWARE.
-*/
-
-/* cJSON */
-/* JSON parser in C. */
-
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#include <float.h>
-#include <limits.h>
-#include <ctype.h>
-#include "cJSON.h"
-
-static const char *ep;
-
-const char *cJSON_GetErrorPtr(void) {return ep;}
-
-static int cJSON_strcasecmp(const char *s1,const char *s2)
-{
-	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
-	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
-	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
-}
-
-static void *(*cJSON_malloc)(size_t sz) = malloc;
-static void (*cJSON_free)(void *ptr) = free;
-
-static char* cJSON_strdup(const char* str)
-{
-      size_t len;
-      char* copy;
-
-      len = strlen(str) + 1;
-      if (!(copy = (char*)cJSON_malloc(len))) return 0;
-      memcpy(copy,str,len);
-      return copy;
-}
-
-void cJSON_InitHooks(cJSON_Hooks* hooks)
-{
-    if (!hooks) { /* Reset hooks */
-        cJSON_malloc = malloc;
-        cJSON_free = free;
-        return;
-    }
-
-	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
-	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
-}
-
-/* Internal constructor. */
-static cJSON *cJSON_New_Item(void)
-{
-	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
-	if (node) memset(node,0,sizeof(cJSON));
-	return node;
-}
-
-/* Delete a cJSON structure. */
-void cJSON_Delete(cJSON *c)
-{
-	cJSON *next;
-	while (c)
-	{
-		next=c->next;
-		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
-		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
-		if (c->string) cJSON_free(c->string);
-		cJSON_free(c);
-		c=next;
-	}
-}
-
-/* Parse the input text to generate a number, and populate the result into item. */
-static const char *parse_number(cJSON *item,const char *num)
-{
-	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
-
-	/* Could use sscanf for this? */
-	if (*num=='-') sign=-1,num++;	/* Has sign? */
-	if (*num=='0') num++;			/* is zero */
-	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
-	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
-	if (*num=='e' || *num=='E')		/* Exponent? */
-	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
-		while (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
-	}
-
-	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
-	
-	item->valuedouble=n;
-	item->valueint=(int)n;
-	item->type=cJSON_Number;
-	return num;
-}
-
-/* Render the number nicely from the given item into a string. */
-static char *print_number(cJSON *item)
-{
-	char *str;
-	double d=item->valuedouble;
-	if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
-	{
-		str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
-		if (str) sprintf(str,"%d",item->valueint);
-	}
-	else
-	{
-		str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
-		if (str)
-		{
-			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,"%.0f",d);
-			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str,"%e",d);
-			else												sprintf(str,"%f",d);
-		}
-	}
-	return str;
-}
-
-/* Parse the input text into an unescaped cstring, and populate item. */
-static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
-static const char *parse_string(cJSON *item,const char *str)
-{
-	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
-	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
-	
-	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
-	
-	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
-	if (!out) return 0;
-	
-	ptr=str+1;ptr2=out;
-	while (*ptr!='\"' && *ptr)
-	{
-		if (*ptr!='\\') *ptr2++=*ptr++;
-		else
-		{
-			ptr++;
-			switch (*ptr)
-			{
-				case 'b': *ptr2++='\b';	break;
-				case 'f': *ptr2++='\f';	break;
-				case 'n': *ptr2++='\n';	break;
-				case 'r': *ptr2++='\r';	break;
-				case 't': *ptr2++='\t';	break;
-				case 'u':	 /* transcode utf16 to utf8. */
-					sscanf(ptr+1,"%4x",&uc);ptr+=4;	/* get the unicode char. */
-
-					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/
-
-					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/
-					{
-						if (ptr[1]!='\\' || ptr[2]!='u')	break;	/* missing second-half of surrogate.	*/
-						sscanf(ptr+3,"%4x",&uc2);ptr+=6;
-						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
-						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
-					}
-
-					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
-					
-					switch (len) {
-						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
-						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
-						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
-						case 1: *--ptr2 =(uc | firstByteMark[len]);
-					}
-					ptr2+=len;
-					break;
-				default:  *ptr2++=*ptr; break;
-			}
-			ptr++;
-		}
-	}
-	*ptr2=0;
-	if (*ptr=='\"') ptr++;
-	item->valuestring=out;
-	item->type=cJSON_String;
-	return ptr;
-}
-
-/* Render the cstring provided to an escaped version that can be printed. */
-static char *print_string_ptr(const char *str)
-{
-	const char *ptr;char *ptr2,*out;int len=0;unsigned char token;
-	
-	if (!str) return cJSON_strdup("");
-	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
-	
-	out=(char*)cJSON_malloc(len+3);
-	if (!out) return 0;
-
-	ptr2=out;ptr=str;
-	*ptr2++='\"';
-	while (*ptr)
-	{
-		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
-		else
-		{
-			*ptr2++='\\';
-			switch (token=*ptr++)
-			{
-				case '\\':	*ptr2++='\\';	break;
-				case '\"':	*ptr2++='\"';	break;
-				case '\b':	*ptr2++='b';	break;
-				case '\f':	*ptr2++='f';	break;
-				case '\n':	*ptr2++='n';	break;
-				case '\r':	*ptr2++='r';	break;
-				case '\t':	*ptr2++='t';	break;
-				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
-			}
-		}
-	}
-	*ptr2++='\"';*ptr2++=0;
-	return out;
-}
-/* Invote print_string_ptr (which is useful) on an item. */
-static char *print_string(cJSON *item)	{return print_string_ptr(item->valuestring);}
-
-/* Predeclare these prototypes. */
-static const char *parse_value(cJSON *item,const char *value);
-static char *print_value(cJSON *item,int depth,int fmt);
-static const char *parse_array(cJSON *item,const char *value);
-static char *print_array(cJSON *item,int depth,int fmt);
-static const char *parse_object(cJSON *item,const char *value);
-static char *print_object(cJSON *item,int depth,int fmt);
-
-/* Utility to jump whitespace and cr/lf */
-static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
-
-/* Parse an object - create a new root, and populate. */
-cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
-{
-	const char *end=0;
-	cJSON *c=cJSON_New_Item();
-	ep=0;
-	if (!c) return 0;       /* memory fail */
-
-	end=parse_value(c,skip(value));
-	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */
-
-	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
-	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
-	if (return_parse_end) *return_parse_end=end;
-	return c;
-}
-/* Default options for cJSON_Parse */
-cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}
-
-/* Render a cJSON item/entity/structure to text. */
-char *cJSON_Print(cJSON *item)				{return print_value(item,0,1);}
-char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0);}
-
-/* Parser core - when encountering text, process appropriately. */
-static const char *parse_value(cJSON *item,const char *value)
-{
-	if (!value)						return 0;	/* Fail on null. */
-	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
-	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
-	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
-	if (*value=='\"')				{ return parse_string(item,value); }
-	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
-	if (*value=='[')				{ return parse_array(item,value); }
-	if (*value=='{')				{ return parse_object(item,value); }
-
-	ep=value;return 0;	/* failure. */
-}
-
-/* Render a value to text. */
-static char *print_value(cJSON *item,int depth,int fmt)
-{
-	char *out=0;
-	if (!item) return 0;
-	switch ((item->type)&255)
-	{
-		case cJSON_NULL:	out=cJSON_strdup("null");	break;
-		case cJSON_False:	out=cJSON_strdup("false");break;
-		case cJSON_True:	out=cJSON_strdup("true"); break;
-		case cJSON_Number:	out=print_number(item);break;
-		case cJSON_String:	out=print_string(item);break;
-		case cJSON_Array:	out=print_array(item,depth,fmt);break;
-		case cJSON_Object:	out=print_object(item,depth,fmt);break;
-	}
-	return out;
-}
-
-/* Build an array from input text. */
-static const char *parse_array(cJSON *item,const char *value)
-{
-	cJSON *child;
-	if (*value!='[')	{ep=value;return 0;}	/* not an array! */
-
-	item->type=cJSON_Array;
-	value=skip(value+1);
-	if (*value==']') return value+1;	/* empty array. */
-
-	item->child=child=cJSON_New_Item();
-	if (!item->child) return 0;		 /* memory fail */
-	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
-	if (!value) return 0;
-
-	while (*value==',')
-	{
-		cJSON *new_item;
-		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
-		child->next=new_item;new_item->prev=child;child=new_item;
-		value=skip(parse_value(child,skip(value+1)));
-		if (!value) return 0;	/* memory fail */
-	}
-
-	if (*value==']') return value+1;	/* end of array */
-	ep=value;return 0;	/* malformed. */
-}
-
-/* Render an array to text */
-static char *print_array(cJSON *item,int depth,int fmt)
-{
-	char **entries;
-	char *out=0,*ptr,*ret;int len=5;
-	cJSON *child=item->child;
-	int numentries=0,i=0,fail=0;
-	
-	/* How many entries in the array? */
-	while (child) numentries++,child=child->next;
-	/* Explicitly handle numentries==0 */
-	if (!numentries)
-	{
-		out=(char*)cJSON_malloc(3);
-		if (out) strcpy(out,"[]");
-		return out;
-	}
-	/* Allocate an array to hold the values for each */
-	entries=(char**)cJSON_malloc(numentries*sizeof(char*));
-	if (!entries) return 0;
-	memset(entries,0,numentries*sizeof(char*));
-	/* Retrieve all the results: */
-	child=item->child;
-	while (child && !fail)
-	{
-		ret=print_value(child,depth+1,fmt);
-		entries[i++]=ret;
-		if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
-		child=child->next;
-	}
-	
-	/* If we didn't fail, try to malloc the output string */
-	if (!fail) out=(char*)cJSON_malloc(len);
-	/* If that fails, we fail. */
-	if (!out) fail=1;
-
-	/* Handle failure. */
-	if (fail)
-	{
-		for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);
-		cJSON_free(entries);
-		return 0;
-	}
-	
-	/* Compose the output array. */
-	*out='[';
-	ptr=out+1;*ptr=0;
-	for (i=0;i<numentries;i++)
-	{
-		strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
-		if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
-		cJSON_free(entries[i]);
-	}
-	cJSON_free(entries);
-	*ptr++=']';*ptr++=0;
-	return out;	
-}
-
-/* Build an object from the text. */
-static const char *parse_object(cJSON *item,const char *value)
-{
-	cJSON *child;
-	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
-	
-	item->type=cJSON_Object;
-	value=skip(value+1);
-	if (*value=='}') return value+1;	/* empty array. */
-	
-	item->child=child=cJSON_New_Item();
-	if (!item->child) return 0;
-	value=skip(parse_string(child,skip(value)));
-	if (!value) return 0;
-	child->string=child->valuestring;child->valuestring=0;
-	if (*value!=':') {ep=value;return 0;}	/* fail! */
-	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
-	if (!value) return 0;
-	
-	while (*value==',')
-	{
-		cJSON *new_item;
-		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
-		child->next=new_item;new_item->prev=child;child=new_item;
-		value=skip(parse_string(child,skip(value+1)));
-		if (!value) return 0;
-		child->string=child->valuestring;child->valuestring=0;
-		if (*value!=':') {ep=value;return 0;}	/* fail! */
-		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
-		if (!value) return 0;
-	}
-	
-	if (*value=='}') return value+1;	/* end of array */
-	ep=value;return 0;	/* malformed. */
-}
-
-/* Render an object to text. */
-static char *print_object(cJSON *item,int depth,int fmt)
-{
-	char **entries=0,**names=0;
-	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
-	cJSON *child=item->child;
-	int numentries=0,fail=0;
-	/* Count the number of entries. */
-	while (child) numentries++,child=child->next;
-	/* Explicitly handle empty object case */
-	if (!numentries)
-	{
-		out=(char*)cJSON_malloc(fmt?depth+3:3);
-		if (!out)	return 0;
-		ptr=out;*ptr++='{';
-		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
-		*ptr++='}';*ptr++=0;
-		return out;
-	}
-	/* Allocate space for the names and the objects */
-	entries=(char**)cJSON_malloc(numentries*sizeof(char*));
-	if (!entries) return 0;
-	names=(char**)cJSON_malloc(numentries*sizeof(char*));
-	if (!names) {cJSON_free(entries);return 0;}
-	memset(entries,0,sizeof(char*)*numentries);
-	memset(names,0,sizeof(char*)*numentries);
-
-	/* Collect all the results into our arrays: */
-	child=item->child;depth++;if (fmt) len+=depth;
-	while (child)
-	{
-		names[i]=str=print_string_ptr(child->string);
-		entries[i++]=ret=print_value(child,depth,fmt);
-		if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
-		child=child->next;
-	}
-	
-	/* Try to allocate the output string */
-	if (!fail) out=(char*)cJSON_malloc(len);
-	if (!out) fail=1;
-
-	/* Handle failure */
-	if (fail)
-	{
-		for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
-		cJSON_free(names);cJSON_free(entries);
-		return 0;
-	}
-	
-	/* Compose the output: */
-	*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
-	for (i=0;i<numentries;i++)
-	{
-		if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
-		strcpy(ptr,names[i]);ptr+=strlen(names[i]);
-		*ptr++=':';if (fmt) *ptr++='\t';
-		strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
-		if (i!=numentries-1) *ptr++=',';
-		if (fmt) *ptr++='\n';*ptr=0;
-		cJSON_free(names[i]);cJSON_free(entries[i]);
-	}
-	
-	cJSON_free(names);cJSON_free(entries);
-	if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
-	*ptr++='}';*ptr++=0;
-	return out;	
-}
-
-/* Get Array size/item / object item. */
-int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
-cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
-cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}
-
-/* Utility for array list handling. */
-static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
-/* Utility for handling references. */
-static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}
-
-/* Add item to array/object. */
-void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
-void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
-void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
-void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}
-
-cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;
-	if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}
-void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
-cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
-void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}
-
-/* Replace array/object items with new ones. */
-void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;
-	newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;
-	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
-void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}
-
-/* Create basic types: */
-cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
-cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
-cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
-cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
-cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
-cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
-cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
-cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}
-
-/* Create Arrays: */
-cJSON *cJSON_CreateIntArray(int *numbers,int count)				{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
-cJSON *cJSON_CreateFloatArray(float *numbers,int count)			{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
-cJSON *cJSON_CreateDoubleArray(double *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
-cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
-
-/* Duplication */
-cJSON *cJSON_Duplicate(cJSON *item,int recurse)
-{
-	cJSON *newitem,*cptr,*nptr=0,*newchild;
-	/* Bail on bad ptr */
-	if (!item) return 0;
-	/* Create new item */
-	newitem=cJSON_New_Item();
-	if (!newitem) return 0;
-	/* Copy over all vars */
-	newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;
-	if (item->valuestring)	{newitem->valuestring=cJSON_strdup(item->valuestring);	if (!newitem->valuestring)	{cJSON_Delete(newitem);return 0;}}
-	if (item->string)		{newitem->string=cJSON_strdup(item->string);			if (!newitem->string)		{cJSON_Delete(newitem);return 0;}}
-	/* If non-recursive, then we're done! */
-	if (!recurse) return newitem;
-	/* Walk the ->next chain for the child. */
-	cptr=item->child;
-	while (cptr)
-	{
-		newchild=cJSON_Duplicate(cptr,1);		/* Duplicate (with recurse) each item in the ->next chain */
-		if (!newchild) {cJSON_Delete(newitem);return 0;}
-		if (nptr)	{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}	/* If newitem->child already set, then crosswire ->prev and ->next and move on */
-		else		{newitem->child=newchild;nptr=newchild;}					/* Set newitem->child and move to it */
-		cptr=cptr->next;
-	}
-	return newitem;
-}
diff --git a/src/global/cJSON.h b/src/global/cJSON.h
deleted file mode 100644
index 1aefe09..0000000
--- a/src/global/cJSON.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
-  Copyright (c) 2009 Dave Gamble
- 
-  Permission is hereby granted, free of charge, to any person obtaining a copy
-  of this software and associated documentation files (the "Software"), to deal
-  in the Software without restriction, including without limitation the rights
-  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-  copies of the Software, and to permit persons to whom the Software is
-  furnished to do so, subject to the following conditions:
- 
-  The above copyright notice and this permission notice shall be included in
-  all copies or substantial portions of the Software.
- 
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-  THE SOFTWARE.
-*/
-
-#ifndef cJSON__h
-#define cJSON__h
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-/* cJSON Types: */
-#define cJSON_False 0
-#define cJSON_True 1
-#define cJSON_NULL 2
-#define cJSON_Number 3
-#define cJSON_String 4
-#define cJSON_Array 5
-#define cJSON_Object 6
-	
-#define cJSON_IsReference 256
-
-/* The cJSON structure: */
-typedef struct cJSON {
-	struct cJSON *next,*prev;	/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
-	struct cJSON *child;		/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
-
-	int type;					/* The type of the item, as above. */
-
-	char *valuestring;			/* The item's string, if type==cJSON_String */
-	int valueint;				/* The item's number, if type==cJSON_Number */
-	double valuedouble;			/* The item's number, if type==cJSON_Number */
-
-	char *string;				/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
-} cJSON;
-
-typedef struct cJSON_Hooks {
-      void *(*malloc_fn)(size_t sz);
-      void (*free_fn)(void *ptr);
-} cJSON_Hooks;
-
-/* Supply malloc, realloc and free functions to cJSON */
-extern void cJSON_InitHooks(cJSON_Hooks* hooks);
-
-
-/* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */
-extern cJSON *cJSON_Parse(const char *value);
-/* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */
-extern char  *cJSON_Print(cJSON *item);
-/* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */
-extern char  *cJSON_PrintUnformatted(cJSON *item);
-/* Delete a cJSON entity and all subentities. */
-extern void   cJSON_Delete(cJSON *c);
-
-/* Returns the number of items in an array (or object). */
-extern int	  cJSON_GetArraySize(cJSON *array);
-/* Retrieve item number "item" from array "array". Returns NULL if unsuccessful. */
-extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);
-/* Get item "string" from object. Case insensitive. */
-extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);
-
-/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
-extern const char *cJSON_GetErrorPtr(void);
-	
-/* These calls create a cJSON item of the appropriate type. */
-extern cJSON *cJSON_CreateNull(void);
-extern cJSON *cJSON_CreateTrue(void);
-extern cJSON *cJSON_CreateFalse(void);
-extern cJSON *cJSON_CreateBool(int b);
-extern cJSON *cJSON_CreateNumber(double num);
-extern cJSON *cJSON_CreateString(const char *string);
-extern cJSON *cJSON_CreateArray(void);
-extern cJSON *cJSON_CreateObject(void);
-
-/* These utilities create an Array of count items. */
-extern cJSON *cJSON_CreateIntArray(int *numbers,int count);
-extern cJSON *cJSON_CreateFloatArray(float *numbers,int count);
-extern cJSON *cJSON_CreateDoubleArray(double *numbers,int count);
-extern cJSON *cJSON_CreateStringArray(const char **strings,int count);
-
-/* Append item to the specified array/object. */
-extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);
-extern void	cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);
-/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
-extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
-extern void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);
-
-/* Remove/Detatch items from Arrays/Objects. */
-extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);
-extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);
-extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);
-extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);
-	
-/* Update array items. */
-extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);
-extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
-
-/* Duplicate a cJSON item */
-extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);
-/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
-need to be released. With recurse!=0, it will duplicate any children connected to the item.
-The item->next and ->prev pointers are always zero on return from Duplicate. */
-
-/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
-extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);
-
-/* Macros for creating things quickly. */
-#define cJSON_AddNullToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateNull())
-#define cJSON_AddTrueToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateTrue())
-#define cJSON_AddFalseToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateFalse())
-#define cJSON_AddBoolToObject(object,name,b)	cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))
-#define cJSON_AddNumberToObject(object,name,n)	cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))
-#define cJSON_AddStringToObject(object,name,s)	cJSON_AddItemToObject(object, name, cJSON_CreateString(s))
-
-/* When assigning an integer value, it needs to be propagated to valuedouble too. */
-#define cJSON_SetIntValue(object,val)			((object)?(object)->valueint=(object)->valuedouble=(val):(val))
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/src/global/header_opts.c b/src/global/header_opts.c
index 19a5d1a..08808f2 100644
--- a/src/global/header_opts.c
+++ b/src/global/header_opts.c
@@ -84,7 +84,6 @@ static const HEADER_OPTS header_opts[] = {
     "Return-Receipt-To", HDR_RETURN_RECEIPT_TO, HDR_OPT_SENDER,
     "Sender", HDR_SENDER, HDR_OPT_SENDER,
     "To", HDR_TO, HDR_OPT_XRECIP,
-    "Subject", HDR_SUBJECT, HDR_OPT_SUBJECT
 };
 
 #define HEADER_OPTS_SIZE (sizeof(header_opts) / sizeof(header_opts[0]))
diff --git a/src/global/header_opts.h b/src/global/header_opts.h
index a5e0ba2..a0f2651 100644
--- a/src/global/header_opts.h
+++ b/src/global/header_opts.h
@@ -54,7 +54,6 @@ typedef struct {
 #define HDR_CONTENT_ID			29
 #define HDR_MIME_VERSION		30
 #define HDR_DISP_NOTIFICATION		31
-#define HDR_SUBJECT     32
 
  /*
   * Header flags.
@@ -65,7 +64,6 @@ typedef struct {
 #define HDR_OPT_RR	(1<<3)		/* Resent- header */
 #define HDR_OPT_EXTRACT	(1<<4)		/* extract flag */
 #define HDR_OPT_MIME	(1<<5)		/* MIME header */
-#define HDR_OPT_SUBJECT (1<<6)  /* Subject line */
 
 #define HDR_OPT_XRECIP	(HDR_OPT_RECIP | HDR_OPT_EXTRACT)
 
diff --git a/src/global/mail_params.h b/src/global/mail_params.h
index 4b0d2ca..2f7e289 100644
--- a/src/global/mail_params.h
+++ b/src/global/mail_params.h
@@ -3660,29 +3660,6 @@ extern char *var_sm_fix_eol;
 #define DEF_DAEMON_OPEN_FATAL	0
 extern bool var_daemon_open_fatal;
 
-/*
- * JSON URL and index name
- */
-#define VAR_QUEUE_METADATA_URL  "queue_metadata_url"
-#define DEF_QUEUE_METADATA_URL  "http://localhost:9300/"
-extern char *var_queue_metadata_url;
-
-#define VAR_QUEUE_METADATA_CHANGEQ_PATH "queue_metadata_changeq_path"
-#define DEF_QUEUE_METADATA_CHANGEQ_PATH "/message/change_queue"
-extern char *var_queue_metadata_changeq_path;
-
-#define VAR_QUEUE_METADATA_CHANGEWT_PATH "queue_metadata_changewt_path"
-#define DEF_QUEUE_METADATA_CHANGEWT_PATH "/message/change_waittime"
-extern char *var_queue_metadata_changewt_path;
-
-#define VAR_QUEUE_METADATA_ADDQ_PATH "queue_metadata_addq_path"
-#define DEF_QUEUE_METADATA_ADDQ_PATH "/message/add"
-extern char *var_queue_metadata_addq_path;
-
-#define VAR_QUEUE_METADATA_RMQ_PATH "queue_metadata_rmq_path"
-#define DEF_QUEUE_METADATA_RMQ_PATH "/message/remove"
-extern char *var_queue_metadata_rmq_path;
-
 /* LICENSE
 /* .ad
 /* .fi
diff --git a/src/global/mail_queue.c b/src/global/mail_queue.c
index 5d5282c..95f8049 100644
--- a/src/global/mail_queue.c
+++ b/src/global/mail_queue.c
@@ -138,8 +138,6 @@
 #define MAIL_QUEUE_INTERNAL
 #include "mail_queue.h"
 
-#include "rest.h"
-
 #define STR	vstring_str
 
 /* mail_queue_dir - construct mail queue directory name */
@@ -271,34 +269,6 @@ int     mail_queue_rename(const char *queue_id, const char *old_queue,
     return (error);
 }
 
-/* mail_queue_rename - move message to another queue */
-
-int     mail_queue_rename_log(const char *queue_id, const char *old_queue,
-			          const char *new_queue, const char *url)
-{
-    VSTRING *old_buf = vstring_alloc(100);
-    VSTRING *new_buf = vstring_alloc(100);
-    int     error;
-
-    restlog_change_queue( url, old_queue, new_queue, queue_id );
-    /*
-     * Try the operation. If it fails, see if it is because of missing
-     * intermediate directories.
-     */
-    error = sane_rename(mail_queue_path(old_buf, old_queue, queue_id),
-			mail_queue_path(new_buf, new_queue, queue_id));
-    if (error != 0 && mail_queue_mkdirs(STR(new_buf)) == 0)
-        error = sane_rename(STR(old_buf), STR(new_buf));
-
-    /*
-     * Cleanup.
-     */
-    vstring_free(old_buf);
-    vstring_free(new_buf);
-
-    return (error);
-}
-
 /* mail_queue_remove - remove mail queue file */
 
 int     mail_queue_remove(const char *queue_name, const char *queue_id)
diff --git a/src/global/mail_queue.h b/src/global/mail_queue.h
index 622896f..cc0d642 100644
--- a/src/global/mail_queue.h
+++ b/src/global/mail_queue.h
@@ -54,7 +54,6 @@
 extern struct VSTREAM *mail_queue_enter(const char *, mode_t, struct timeval *);
 extern struct VSTREAM *mail_queue_open(const char *, const char *, int, mode_t);
 extern int mail_queue_rename(const char *, const char *, const char *);
-extern int mail_queue_rename_log(const char *, const char *, const char *, const char *);
 extern int mail_queue_remove(const char *, const char *);
 extern const char *mail_queue_dir(VSTRING *, const char *, const char *);
 extern const char *mail_queue_path(VSTRING *, const char *, const char *);
diff --git a/src/global/rest.c b/src/global/rest.c
deleted file mode 100644
index ca7eecb..0000000
--- a/src/global/rest.c
+++ /dev/null
@@ -1,149 +0,0 @@
-/* Std */
-#include <sys_defs.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <ctype.h>
-
-#include <msg.h>
-#include <events.h>
-#include <vstream.h>
-#include <dict.h>
-
-/* Service */
-#include <curl/curl.h>
-#include "cJSON.h"
-
-/* Own */
-#include <string.h>
-#include "rest.h"
-
-static CURL *curl_handler;
-
-static size_t read_callback( const void *out, const size_t size, const size_t nmemb, const void *in) {
-    struct inmem_s *in_data = (struct inmem_s *)in;
-    size_t in_size = 0;
-
-    if ( size*nmemb < 1 || in_data->left == 0 )
-        return 0;
-    if ( in_data->left <= size*nmemb )
-        in_size = in_data->left;
-    else
-        in_size = size*nmemb - 1;
-    memcpy( out, in_data->ptr, in_size );
-    in_data->left = in_data->left - in_size;
-    in_data->ptr = in_data->ptr + in_size;
-    return in_size;
-}
-
-CURLcode perform_put( const char *url, const cJSON *json ) {
-    struct inmem_s json_data;
-    CURLcode res;
-
-    json_data.ptr = cJSON_PrintUnformatted( json );
-    json_data.left = strlen( json_data.ptr );
-    if ( msg_verbose )
-        msg_info("json_data: %s", json_data.ptr );
-    curl_handler = curl_easy_init();
-    if ( curl_handler ) {
-        curl_easy_setopt( curl_handler, CURLOPT_URL, url );
-        curl_easy_setopt( curl_handler, CURLOPT_NOPROGRESS, 1L );
-        curl_easy_setopt( curl_handler, CURLOPT_TIMEOUT, 5L );
-        curl_easy_setopt( curl_handler, CURLOPT_VERBOSE, 0L );
-        curl_easy_setopt( curl_handler, CURLOPT_UPLOAD, 1L );
-        curl_easy_setopt( curl_handler, CURLOPT_READDATA, &json_data );
-        curl_easy_setopt( curl_handler, CURLOPT_READFUNCTION, read_callback );
-        curl_easy_setopt( curl_handler, CURLOPT_INFILESIZE, json_data.left );
-        // Still OK until this moment
-        res = curl_easy_perform( curl_handler );
-        curl_easy_cleanup( curl_handler );
-    } else {
-        msg_error("curl_handler BROKEN!");
-    }
-    return res;
-}
-
-void restlog_change_queue( const char *url, const char *queue_from, const char *queue_to, const char *queue_id ) {
-    cJSON *root;
-    CURLcode res;
-
-    /* Create JSON object to transfer to index */
-    root = cJSON_CreateObject();
-    cJSON_AddItemToObject( root, "queue_from", cJSON_CreateString( queue_from ) );
-    cJSON_AddItemToObject( root, "queue_id", cJSON_CreateString( queue_id ) );
-    cJSON_AddItemToObject( root, "queue_to", cJSON_CreateString( queue_to ) );
-    cJSON_AddItemToObject( root, "action", cJSON_CreateString( "message_queue_changed" ) );
-
-    res = perform_put( url, root );
-    if ( res != CURLE_OK ) {
-            msg_warn("curl_easy_perform() failed: %s", curl_easy_strerror(res) );
-    }
-
-    /* Cleanup JSON object*/
-    cJSON_Delete( root );
-}
-
-void restlog_change_wait_time( const char *url, const char *queue_id, size_t wait_time) {
-    cJSON *root;
-    CURLcode res;
-
-    /* Create JSON object to transfer to index */
-    root = cJSON_CreateObject();
-    cJSON_AddItemToObject( root, "queue_id", cJSON_CreateString( queue_id ) );
-    cJSON_AddItemToObject( root, "wait_time", cJSON_CreateNumber( wait_time ) );
-    cJSON_AddItemToObject( root, "action", cJSON_CreateString( "message_next_retry" ) );
-
-    res = perform_put( url, root );
-    if ( res != CURLE_OK ) {
-            msg_warn("curl_easy_perform() failed: %s", curl_easy_strerror(res) );
-    }
-
-    /* Cleanup JSON object*/
-    cJSON_Delete( root );
-}
-
-void restlog_queued( const char *url, const char *queue_id,
-    const char *queue_name, const char *env_sender,
-    const char* recip, const int rcpt_count, const char *subject,
-    const unsigned long msg_size ) {
-    cJSON *root;
-    CURLcode res;
-
-    /* Create JSON object to transfer to index */
-    root = cJSON_CreateObject();
-    cJSON_AddItemToObject( root, "queue_id", cJSON_CreateString( queue_id ) );
-    cJSON_AddItemToObject( root, "queue_name", cJSON_CreateString( queue_name ) );
-    cJSON_AddItemToObject( root, "sender", cJSON_CreateString( env_sender ) );
-    cJSON_AddItemToObject( root, "recipient", cJSON_CreateString( recip ) );
-    cJSON_AddItemToObject( root, "rcpt_count", cJSON_CreateNumber( rcpt_count ) );
-    cJSON_AddItemToObject( root, "msg_size", cJSON_CreateNumber( msg_size ) );
-    cJSON_AddItemToObject( root, "subject", cJSON_CreateString( subject ) );
-    cJSON_AddItemToObject( root, "action", cJSON_CreateString( "message_added" ) );
-
-    res = perform_put( url, root );
-    if ( res != CURLE_OK ) {
-            msg_warn("curl_easy_perform() failed: %s", curl_easy_strerror(res) );
-    }
-
-    /* Cleanup JSON object*/
-    cJSON_Delete( root );
-}
-
-void restlog_message_sent( const char *url, const char *queue_name, const char *queue_id ) {
-    cJSON *root;
-    CURLcode res;
-
-    /* Create JSON object to transfer to index */
-    root = cJSON_CreateObject();
-    cJSON_AddItemToObject( root, "queue_id", cJSON_CreateString( queue_id ) );
-    cJSON_AddItemToObject( root, "queue", cJSON_CreateString( queue_name ) );
-    cJSON_AddItemToObject( root, "finished", cJSON_CreateNumber( 1 ) );
-    cJSON_AddItemToObject( root, "action", cJSON_CreateString( "message_sent" ) );
-
-    res = perform_put( url, root );
-    if ( res != CURLE_OK ) {
-            msg_warn("curl_easy_perform() failed: %s", curl_easy_strerror(res) );
-    }
-
-    /* Cleanup JSON object*/
-    cJSON_Delete( root );
-}
diff --git a/src/global/rest.h b/src/global/rest.h
deleted file mode 100644
index 564d9cd..0000000
--- a/src/global/rest.h
+++ /dev/null
@@ -1,24 +0,0 @@
-#ifndef REST_H_INCLUDED
-#define REST_H_INCLUDED
-
-#include <curl/curl.h>
-#include "cJSON.h"
-
-struct inmem_s {
-    const char *ptr;
-    size_t left;
-};
-
-CURLcode perform_put( const char *url, const cJSON *json );
-void restlog_change_queue( const char *url, const char *queue_from,
-    const char *queue_to, const char *queue_id );
-void restlog_change_wait_time( const char *url, const char *queue_id,
-    size_t wait_time);
-void restlog_queued( const char *url, const char *queue_id,
-    const char *queue_name, const char *env_sender,
-    const char* recip, const int rcpt_count, const char *subject,
-    const unsigned long msg_size );
-void restlog_message_sent( const char *url, const char *queue_name,
-    const char *queue_id );
-
-#endif // REST_H_INCLUDED
diff --git a/src/qmgr/Makefile.in b/src/qmgr/Makefile.in
index 466af7f..bd63a9b 100644
--- a/src/qmgr/Makefile.in
+++ b/src/qmgr/Makefile.in
@@ -11,7 +11,7 @@ OBJS	= qmgr.o qmgr_active.o qmgr_transport.o qmgr_queue.o qmgr_entry.o \
 	qmgr_feedback.o
 HDRS	= qmgr.h
 TESTSRC	=
-DEFS	= -I. -I$(INC_DIR) -D$(SYSTYPE) -I/usr/include
+DEFS	= -I. -I$(INC_DIR) -D$(SYSTYPE)
 CFLAGS	= $(DEBUG) $(OPT) $(DEFS)
 TESTPROG= 
 PROG	= qmgr
@@ -21,7 +21,7 @@ LIBS	= ../../lib/libmaster.a ../../lib/libglobal.a ../../lib/libutil.a
 .c.o:;	$(CC) $(CFLAGS) -c $*.c
 
 $(PROG):	$(OBJS) $(LIBS)
-	$(CC) $(LDFLAGS) $(CFLAGS) -o $@ $(OBJS) $(LIBS) $(SYSLIBS)
+	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LIBS) $(SYSLIBS)
 
 $(OBJS): ../../conf/makedefs.out
 
diff --git a/src/qmgr/qmgr.c b/src/qmgr/qmgr.c
index 3253bf4..fbf7dab 100644
--- a/src/qmgr/qmgr.c
+++ b/src/qmgr/qmgr.c
@@ -406,7 +406,6 @@
 /* Application-specific. */
 
 #include "qmgr.h"
-#include "rest.h"
 
  /*
   * Tunables.
@@ -445,14 +444,6 @@ int     var_dest_rate_delay;
 char   *var_def_filter_nexthop;
 int     var_qmgr_daemon_timeout;
 int     var_qmgr_ipc_timeout;
-char    *var_queue_metadata_url;
-char    *var_queue_metadata_changeq_path;
-char    *var_queue_metadata_addq_path;
-char    *var_queue_metadata_changewt_path;
-
-char    *rename_url;
-char    *wt_url;
-char    *sent_url;
 
 static QMGR_SCAN *qmgr_scans[2];
 
@@ -634,17 +625,6 @@ static void qmgr_pre_init(char *unused_name, char **unused_argv)
 static void qmgr_post_init(char *name, char **unused_argv)
 {
 
-    /* Initialize rename_url */
-    rename_url = (char *) mystrdup( var_queue_metadata_url );
-    rename_url = (char *) myrealloc( rename_url, strlen(var_queue_metadata_url) + strlen(var_queue_metadata_changeq_path ) + 2 );
-    rename_url = strcat(rename_url, var_queue_metadata_changeq_path);
-    wt_url = (char *) mystrdup( var_queue_metadata_url );
-    wt_url = (char *) myrealloc( wt_url, strlen(var_queue_metadata_url) + strlen(var_queue_metadata_changewt_path ) + 2 );
-    wt_url = strcat( wt_url, var_queue_metadata_changewt_path );
-    sent_url = (char *) mystrdup( var_queue_metadata_url );
-    sent_url = (char *) myrealloc( sent_url, strlen(var_queue_metadata_url) + strlen(var_queue_metadata_addq_path ) + 2 );
-    sent_url = strcat( sent_url, var_queue_metadata_addq_path );
-
     /*
      * Backwards compatibility.
      */
@@ -704,10 +684,6 @@ int     main(int argc, char **argv)
 	VAR_CONC_POS_FDBACK, DEF_CONC_POS_FDBACK, &var_conc_pos_feedback, 1, 0,
 	VAR_CONC_NEG_FDBACK, DEF_CONC_NEG_FDBACK, &var_conc_neg_feedback, 1, 0,
 	VAR_DEF_FILTER_NEXTHOP, DEF_DEF_FILTER_NEXTHOP, &var_def_filter_nexthop, 0, 0,
-	VAR_QUEUE_METADATA_URL, DEF_QUEUE_METADATA_URL, &var_queue_metadata_url, 1, 0,
-	VAR_QUEUE_METADATA_CHANGEQ_PATH, DEF_QUEUE_METADATA_CHANGEQ_PATH, &var_queue_metadata_changeq_path, 1, 0,
-	VAR_QUEUE_METADATA_CHANGEWT_PATH, DEF_QUEUE_METADATA_CHANGEWT_PATH, &var_queue_metadata_changewt_path, 1, 0,
-	VAR_QUEUE_METADATA_ADDQ_PATH, DEF_QUEUE_METADATA_ADDQ_PATH, &var_queue_metadata_addq_path, 1, 0,
 	0,
     };
     static const CONFIG_TIME_TABLE time_table[] = {
diff --git a/src/qmgr/qmgr.h b/src/qmgr/qmgr.h
index dab79f1..6737e42 100644
--- a/src/qmgr/qmgr.h
+++ b/src/qmgr/qmgr.h
@@ -1,6 +1,3 @@
-#ifndef QMGR_H_INCLUDED
-#define QMGR_H_INCLUDED
-
 /*++
 /* NAME
 /*	qmgr 3h
@@ -537,4 +534,3 @@ extern char *qmgr_error_nexthop(DSN *);
 /*	Modra 6
 /*	155 00, Prague, Czech Republic
 /*--*/
-#endif
diff --git a/src/qmgr/qmgr_active.c b/src/qmgr/qmgr_active.c
index c7ffe3a..d93a2cd 100644
--- a/src/qmgr/qmgr_active.c
+++ b/src/qmgr/qmgr_active.c
@@ -111,11 +111,6 @@
 /* Application-specific. */
 
 #include "qmgr.h"
-#include "rest.h"
-
-extern char* rename_url;
-extern char* wt_url;
-extern char* sent_url;
 
  /*
   * A bunch of call-back routines.
@@ -160,7 +155,7 @@ static void qmgr_active_defer(const char *queue_name, const char *queue_id,
     path = mail_queue_path((VSTRING *) 0, queue_name, queue_id);
     if (utime(path, &tbuf) < 0 && errno != ENOENT)
 	msg_fatal("%s: update %s time stamps: %m", myname, path);
-    if (mail_queue_rename_log(queue_id, queue_name, dest_queue, rename_url)) {
+    if (mail_queue_rename(queue_id, queue_name, dest_queue)) {
 	if (errno != ENOENT)
 	    msg_fatal("%s: rename %s from %s to %s: %m", myname,
 		      queue_id, queue_name, dest_queue);
@@ -203,7 +198,6 @@ int     qmgr_active_feed(QMGR_SCAN *scan_info, const char *queue_id)
 	if (msg_verbose)
 	    msg_info("%s: skip %s (%ld seconds)", myname, queue_id,
 		     (long) (st.st_mtime - event_time()));
-    restlog_change_wait_time( wt_url, queue_id, (size_t) (st.st_mtime - event_time()) );
 	return (0);
     }
 
@@ -560,7 +554,6 @@ static void qmgr_active_done_3_generic(QMGR_MESSAGE *message)
 	    /* Same format as logged by postsuper. */
 	    msg_info("%s: removed", message->queue_id);
 	}
-        restlog_message_sent( sent_url, message->queue_name, message->queue_id );
     }
 
     /*
diff --git a/tools/JSON-debug-server.pl b/tools/JSON-debug-server.pl
deleted file mode 100755
index 13ac920..0000000
--- a/tools/JSON-debug-server.pl
+++ /dev/null
@@ -1,21 +0,0 @@
-#!/usr/bin/perl
-
-use warnings;
-use strict;
-
-use Mojolicious::Lite;
-use Mojo::Log;
-use JSON;
-
-app->hook( 'before_dispatch' => sub {
-    my $c = shift;
-    $c->app->log->info("url:".$c->req->url." body: ".$c->req->body);
-    $c->render( json => { code => 200, url => $c->req->url, method => $c->req->method, body => $c->req->body } )
-});
-
-get '/' => sub {
-    my $self = shift;
-    $self->render( text => 'Oops!' );
-};
-
-app->start;
